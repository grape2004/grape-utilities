<!DOCTYPE html>
<html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="content-language" content="ja">
<meta name="robots" content="noydir,noodp">
<title>grape.utility.functions</title>
<script src="./jquery.js?body=1"></script>
<script src="./utilities/grape-utility-string.js"></script>
<style>
/*--------------------------------------
html
--------------------------------------*/
body
{ font-size:16px; font-family: 'Hiragino Kaku Gothic ProN', 'ヒラギノ角ゴ ProN W3', Meiryo, メイリオ, Osaka, 'MS PGothic', arial, helvetica, sans-serif; }
h1
{ font-size:30px; margin:0 0 20px 0; }
h2
{ font-size:26px; margin:0 0 20px 0; }
h3
{ font-size:20px; margin:0; }
table
{ border-collapse: collapse; }
td
{ border: 1px solid #000; vertical-align:top; text-align:right; min-width:2em; }
th
{ border: 1px solid #000; vertical-align:top; text-align:center; min-width:2em; background-color:#333; color:white; font-weight:normal; }
/*--------------------------------------
layout
--------------------------------------*/
.contents
{  }
.page
{ margin:0 0 40px 20px; }
.section
{ margin:0 0 20px 20px; }
.mrTop20
{ margin-top:20px; }
.mrTop40
{ margin-top:40px; }
.mrTop60
{ margin-top:60px; }
.mrBottom20
{ margin-bottom:20px; }
.mrBottom40
{ margin-bottom:40px; }
.mrBottom60
{ margin-bottom:60px; }
.text
{ margin-left:20px; white-space:pre-line; }
.code
{ margin:10px; border:1px solid #0000FF; padding:10px; white-space:pre-wrap; font-family: Osaka-mono, "Osaka-等幅", "ＭＳ ゴシック", monospace; }
.quote
{ margin:10px; border:1px dashed #0000FF; padding:10px; white-space:pre-wrap; }
.indent
{ margin-left:20px; }
/*--------------------------------------
typical
--------------------------------------*/
.bgWhite
{ background-color:#FFFFFF; }
.bgLightBlue
{ background-color:#F0F0FF; }
/*--------------------------------------
private
--------------------------------------*/
.comment
{ color:#309020 }
.index-initial
{ float:left; width:2em; clear:left; }
</style>
<script type="text/javascript">
/*--------------------------------------
For html
--------------------------------------*/
$(function(){
  // code and quote fix up
  $(".code,.quote").each(function(){
    $(this).html( 
      $(this).html().replace(
        /(^[\r\n]+|[ \t\r\n]+$)/g, "" 
      ).replace( 
        /[\r\n]/g, "\n" 
      ).replace( 
        /[ \t]/g, " "
      )
    );
    var indent_ = $(this).html().match(/^[ ]+/)[0] || "";
    $(this).html( 
      $(this).html().replace(
        ( new RegExp( "^" + indent_, "g" ) ), ""
      ).replace(
        ( new RegExp( "\n" + indent_, "g" ) ), "\n"
      )
    );
  });
  $(".code").each(function(){
    $(this).html( 
      $(this).html().replace( 
        /(\/\/.*)/g, "<span class='comment'>$1</span>"
      )
    );
  });
  
  /*--------------------------------------
  make functions index
  --------------------------------------*/
  
  // find files
  var files_ = [];
  $("#index a").each(function(){
    files_[files_.length] = $(this).attr("href").slice(1);
  });

  // make index each files
  for (var i_=0; i_<files_.length; i_++) {
    var page_ = $("#" + files_[i_]);
    var links_ = $("<div class='indent'></div>");

    // find functions
    var fname_nodes_ = $("#" + files_[i_] + " h3"); // function title nodes
    var fnames_ = []; // function names
    var fname_to_nodes = []; // Hash of objects(function title and parent nodes) by function name of key
    fname_nodes_.each(function(){ 
      var fname_ = $(this).text();
      fnames_[ fnames_.length ] = fname_;
      fname_to_nodes[ fname_ ] = { title: $(this), parent: $(this).parent() };
    });
    fnames_ = fnames_.sort(); // sort function names

    // re-place to each initial alphabet.
    var alphabet_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var az_index_ = [];
    for(var j_=0; j_<alphabet_.length; j_++) { az_index_[j_] = [] }
    for(var j_=0; j_<fnames_.length; j_++){
      var initial_index_ = alphabet_.search( fnames_[j_].charAt(0).toUpperCase() );
      if ( 0 > initial_index_ || alphabet_.length <= initial_index_ ) initial_index_ = alphabet_.length-1;
      az_index_[ initial_index_ ][ az_index_[ initial_index_ ].length ] = fnames_[j_];
    }

    // make link elements for index and page-jump
    for(var j_=0; j_<alphabet_.length; j_++){
      fnames_ = az_index_[j_];
      if ( 0 == fnames_.length ) continue;
      links_.append( "<div class='index-initial'>" + alphabet_.charAt(j_) + " </div>: " );
      for(var k_=0; k_<fnames_.length; k_++){
        var fname_ = fnames_[k_];
        fname_to_nodes[fname_].title.before( $("<a name='" + files_[i_] + "-" + fname_ + "'></a>") );
        var link_ = $("<a href='#" + files_[i_] + "-" + fname_ + "'></a>").append( fname_ );
        links_.append( link_ );
        if ( k_ < fnames_.length - 1 ) {
          links_.append( "、" );
        }
        // reposition html.
        fname_to_nodes[fname_].parent.detach();
        page_.find(".section").append( fname_to_nodes[fname_].parent );
      }
      links_.append( $("<br/>") );
    }
    $("#index-" + files_[i_] ).after( links_ );
  }

  // make page-jump from relation
  $(".relations").each(function(){
    var self = $(this);
    var file_name = self.closest(".page").attr("id");
    var text = self.text().replace(/(^[ \t\r\n]+|[ \t\r\n]+$)/g, "");
    self.html( text.replace( /([a-zA-Z0-9]+)/g, function( all, fnc_name ){
      var jump_name = file_name + "-" + fnc_name;
      return 0 < $("a[name="+jump_name+"]").length ? "<a href='#"+jump_name+"'>"+fnc_name+"</a>" : fnc_name;
    } ) );
  });
  

} );
</script>

</head>

<body>
  <div class="contents">
    <h1>ユーティリティ / ライブラリ</h1>
    <div class="page" id="index">
      <h2>目次</h2>
      <div class="section">
        <div class="text">
          <a href="#grape-utility-string"   id="index-grape-utility-string">文字列</a>
          <a href="#grape-utility-number"   id="index-grape-utility-number">数値</a>
          <a href="#grape-utility-array"    id="index-grape-utility-array">配列</a>
          <a href="#grape-utility-datetime" id="index-grape-utility-datetime">日付</a>
          <a href="#grape-libraries-algorithm" id="index-grape-libraries-algorithm">汎用アルゴリズム</a>
        </div>
      </div>
    </div>
    <div class="page">
      <h2>ダウンロード</h2>
      <div class="section">
        <div class="text">
          ver 0.01 (2017/08/14) : <a href="./utilities/grape-utility-string.js" target="_blank">Download</a><br/>
        </div>
      </div>
    </div>
    <div class="page">
      <h2>使用方法（共通）</h2>
      <div class="section">
        <div class="text">
          使用したいユーティリティ/ライブラリを、HEAD要素内のSCRIPT要素で読み込みます。

          例：
          <div class="code">
            &lt;script src="./grape-utility-string.js"&gt;&lt;/script&gt;
            &lt;script type="text/javascript"&gt;

              // 自動的に変数 $ustr が定義されます。
              $ustr.capitalize( "hello" );   // -> "Hello"

              // 任意の変数に割り当てることもできます。
              var foo = new $UStr();
              foo.capitalize( "world" );    // -> "World"

              // インスタンス生成時に文字列を設定し、メソッドチェーンを使用することもできます。
              var bar = new $UStr( "utility" );
              bar.capitalize.center( 15, '-' );  // -> "----Utility----"

            &lt;/script&gt;
          </div>
        </div>
      </div>
    </div>
    <div class="page" id="grape-utility-string">
      <h2>文字列</h2>
      <a name="grape-utility-string"></a>
      <div class='text'>
        ファイル : <a href="./utilities/grape-utility-string.js" target="_blank">grape-utility-string.js</a>
        オブジェクト型 : $UStr
        インスタンス : $ustr
        
      </div>
      <div class="section">
        <div>
          <h3>bin</h3>
          <div class="text">
            文字列を2進数とみなし、整数（数値）に変換します。
            文字列の先頭に0bを含むことができます。
            数値に変換できない場合には、0を返します。

            Number ret = bin( String str )
            str : 変換対象の文字列を指定します。
            ret : 変換した数値を返します。
            
            <div class='relations'>
              関連：dec、hex、oct
            </div>

          </div>
        </div>
        <div>
          <h3>bytes</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、eachByteの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>byteSize</h3>
          <div class="text">
            文字列のbyteサイズを取得します。

            Number ret = byteSize( String str )
            str : 文字列を指定します。
            ret : byteサイズを返します。

            <div class='relations'>
              本メソッドは、byteLengthの別名です。
              関連：eachByte、getByte、toByteArray
            </div>
            
          </div>
        </div>
        <div>
          <h3>size</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、bytesの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>byteLength</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、byteSizeの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>capitalize</h3>
          <div class="text">
            文字列（英単語）の最初の1文字目を大文字にします。

            String ret = capitalize( String str )
            str : 変換対象の文字列を指定します。
            ret : 変換後の文字列を返します。

            例：
            <div class="code">
              $ustr.capitalize( "capitalize" );
              > "Capitalize"
            </div>
            <div class='relations'>
              関連：casecmp、toLowerCase、toUpperCase
            </div>
            
          </div>
        </div>
        <div>
          <h3>casecmp</h3>
          <div class="text">
            大文字小文字を区別せずに比較します。
            文字が異なる場合には、ソート順位の前後で、-1か1を返します。

            Number ret = casecmp( String str1, String str2 )
            str1 : 比較元の文字列を指定します。
            str2 : 比較先の文字列を指定します。
            ret : (0)同じ (-1)比較元が先 (1)比較元が後

            例：
            <div class="code">
              $ustr.casecmp( "abc", "Abc" );
              > 0
              $ustr.casecmp( "abc", "def" );
              > -1
            </div>          
            <div class='relations'>
              関連：capitalize、toLowerCase、toUpperCase
            </div>

          </div>
        </div>
        <div>
          <h3>center</h3>
          <div class="text">
            文字列を指定文字数内で中央寄せをします。

            String ret = center( String str, Number num, String pad = " " )
            str : 中央寄せしたい文字列を指定します。
            num : 中央寄せする行の最大文字数を指定します。
            pad : (option) 中央寄せの際に埋める文字（デフォルトは空白文字）を指定します。
            ret : 中央寄せした文字列を返します。

            例：
            <div class="code">
              $ustr.center( "center", 10 );
              > "  center  "
              $ustr.center( "center", 15, "-*" );
              > "-*-*center-*-*-"
            </div>

            <div class='relations'>
              関連：right、left
            </div>

          </div>
        </div>
        <div>
          <h3>chomp</h3>
          <div class="text">
            文字列の末尾の改行コードを消した文字列を返します
            \r, \n, \r\n は、いずれも1つの改行コードとして処理します。

            String ret = chomp( String str )
            str : 末尾の改行コードを削除したい文字列を指定します。
            ret : 末尾の改行コードを削除した文字列を返します。

          </div>
        </div>
        <div>
          <h3>chop</h3>
          <div class="text">
            文字列の末尾の文字を消した文字列を返します
            ただし、末尾が\r\nによる2byteの改行コードだった場合には、2byte分を削除します。

            String ret = chomp( String str )
            str : 末尾の文字を削除したい文字列を指定します。
            ret : 末尾の文字を削除した文字列を返します。

          </div>
        </div>
        <div>
          <h3>cjust</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、centerの別名です。
            </div>
            
          </div>
        </div>
        <div>
          <h3>count</h3>
          <div class="text">
            文字列中に含まれる、指定文字（正規表現文字列）の数を返します。
            第三引数以降を指定した場合には、AND条件で対象を絞り込むことが可能です。
            条件が複数存在する場合には、第四、第五引数など可変長引数での指定が可能で、これらの条件同士はANDとなります。
            また、一致条件には文字列の他、正規表現を使用することが可能です。

            Number ret = count( String str, String phraze, String conditions... )
            str : 検索元の文字列を指定します。
            phraze : カウントしたい文字列（正規表現文字列）を指定します。
            conditions : (option) 絞り込み条件を追加指定します。
            ret : カウント数を返します。

          </div>
        </div>
        <div>
          <h3>dec</h3>
          <div class="text">
            文字列を10進数の整数（数値）に変換します。
            文字列の先頭に¥または$を含むことができます。
            また、文字列中に,を含むことができます。
            小数点以下は無視されます。
            数値に変換できない場合には、0を返します。

            Number ret = dec( String str )
            str : 変換対象の文字列を指定します。
            ret : 変換した数値を返します。
            
            <div class='relations'>
              関連：bin、float、hex、oct
            </div>

          </div>
        </div>
        <div>
          <h3>each</h3>
          <div class="text">
            1行づつ取り出して、ブロックを実行します

            each( String str, Function fnc )
            str : 文字列(複数行)を指定します。
            fnc : 1行につき1回、thisに取り出した文字列を引き渡して実行します。

            例：
            <div class="code">
              $ustr.each( "abc\ndef", function(){ 
                console.log( this ) 
              } );
              > "abc"
              > "def"
            </div>
            <div class='relations'>
              本メソッドは、eachLine、linesの別名です。
              関連：byteSize、eachByte、eachChar
            </div>

          </div>
        </div>
        <div>
          <h3>eachByte</h3>
          <div class="text">
            1byteづつ取り出して、ブロックを実行します

            eachByte( String str, Function fnc )
            str : 文字列(複数行)を指定します。
            fnc : 1byteにつき1回、thisに取り出したバイトコードを引き渡して実行します。

            例：
            <div class="code">
              $ustr.eachByte( "abc", function(){ 
                console.log( this ) 
              } );
              > 0x61
              > 0x62
              > 0x63
            </div>
            <div class='relations'>
              関連：byteSize、each、eachChar、toByteArray、charCodeAt
            </div>
            
          </div>
        </div>
        <div>
          <h3>eachChar</h3>
          <div class="text">
            1文字づつ取り出して、ブロックを実行します。
            ただし、¥r¥nによる改行コードは2文字として扱われます

            eachChar( String str, Function fnc )
            str : 文字列(複数行)を指定します。
            fnc : 1文字につき1回、thisに取り出した文字列を引き渡して実行します。

            例：
            <div class="code">
              $ustr.eachChar( "abc", function(){ 
                console.log( this ) 
              } );
              > "a"
              > "b"
              > "c"
            </div>
            <div class='relations'>
              関連：each、eachByte、charAt
            </div>
            
          </div>
        </div>
        <div>
          <h3>eachLine</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、eachの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>fill</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、paddingの別名です。
            </div>
            
          </div>
        </div>
        <div>
          <h3>float</h3>
          <div class="text">
            文字列を実数（小数を含んだ数値）とみなして変換します。
            文字列の先頭に¥または$を含むことができます。
            また、文字列中に,を含むことができます。
            変換できない場合には、0を返します。

            Number ret = float( String str )
            str : 変換対象の文字列を指定します。
            ret : 変換した数値を返します。
            
            <div class='relations'>
              関連：dec
            </div>

          </div>
        </div>
        <div>
          <h3>getByte</h3>
          <div class="text">
            文字列の指定byte目の、任意のバイトコードを取得します。
            位置は0オリジンで指定し、1byte目を0。2byte目を1とします。
            マイナス値を指定した場合には、文字列の末尾から数えたbyte数となり、
            -1は末尾のバイトコードを、-2は末尾から2番目のバイトコードとなります。
            範囲外の位置を指定した場合には、0を返します。

            Number ret = getByte( String str, Number index )
            str : 対象の文字列を指定します。
            index : 取得したいbyte単位の位置
            ret : バイトコードを返します。

            <div class='relations'>
              関連：byteSize、eachByte、setByte、toByteArray、charAt、charCodeAt
            </div>
            
          </div>
        </div>
        <div>
          <h3>hex</h3>
          <div class="text">
            文字列を16進数とみなし、整数（数値）に変換します。
            文字列の先頭に0xを含むことができます。
            数値に変換できない場合には、0を返します。

            Number ret = hex( String str )
            str : 変換対象の文字列を指定します。
            ret : 変換した数値を返します。
            
            <div class='relations'>
              関連：bin、dec、oct
            </div>

          </div>
        </div>
        <div>
          <h3>index</h3>
          <div class="text">
            文字列内に指定の文字列（正規表現文字列）が含まれているとき、最初に見つかった位置を返します。
            文字の位置は、1文字目を0、2文字目を1とし、文字列が含まれていない時にはnullを返します。
            offsetに文字位置を指定した場合には、それ以前の文字列を無視します。
            offsetは文字列の先頭から数えて、1文字目を0、2文字目を1として指定します。
            offsetに3を指定した場合には、3文字目以前を無視して処理します。
            
            Number ret = index( String str, String phraze, Number offset )
            str : 判定対象の文字列を指定します。
            phraze : 判定対象に含まれる文字列（正規表現文字列）を指定します。
            offset : (option) 検索を開始する文字位置を指定します。
            ret : str内のphrazeを含む位置を返します。
            
            <div class='relations'>
              関連：isInclude、rindex、lastIndexOf、search
            </div>
            
          </div>
        </div>
        <div>
          <h3>insert</h3>
          <div class="text">
            文字列中の指定位置に文字列を挿入して返します。

            String ret = insert( String str, Number index, String other )
            str : 挿入先の文字列を指定します。
            index : 挿入位置を指定します。0は文字の先頭。1は1文字目の後。-1は文末、-2は最後の文字の前に挿入します。
            other : 挿入したい文字列を指定します。
            ret : 挿入後の文字列を返します。
            
            例：
            <div class="code">
              $ustr.insert( "aaa", 0, "_bbb_" );
              > "_bbb_aaa"
              $ustr.insert( "aaa", 1, "_bbb_" );
              > "a_bbb_aa"
              $ustr.insert( "aaa", -1, "_bbb_" );
              > "aaa_bbb_"
            </div>
          </div>
        </div>
        <div>
          <h3>isEmpty</h3>
          <div class="text">
            文字列が空文字か否かを返します。

            Boolean ret = isEmpty( String str )
            str : 判定対象の文字列を指定します。
            ret : 空文字（またはNULL、undefined）ならばtrue、そうでなければfalseを返します。

          </div>
        </div>
        <div>
          <h3>isEndWith</h3>
          <div class="text">
            文字列の末尾が指定の文字列（正規表現文字列）であるか否かを返す

            Boolean ret = isEndWith( String str, String phraze )
            str : 判定対象の文字列を指定します。
            phraze : 末尾の文字列（正規表現文字列）を指定します。
            ret : strの末尾がphrazeであるならばtrue、そうでなければfalseを返します。
            
            例：
            <div class="code">
              $ustr.isEndWith( "abc,def", "def" );
              > true
            </div>
            <div class='relations'>
              関連：isStartWith、isInclude
            </div>
            
          </div>
        </div>
        <div>
          <h3>isInclude</h3>
          <div class="text">
            文字列内に指定の文字列（正規表現文字列）が含まれているか否かを返す

            Boolean ret = isInclude( String str, String phraze )
            str : 判定対象の文字列を指定します。
            phraze : 判定対象に含まれる文字列（正規表現文字列）を指定します。
            ret : str内にphrazeを含むならばtrue、そうでなければfalseを返します。
            
            例：
            <div class="code">
              $ustr.isInclude( "abc,def", "[\w]+" );
              > true
            </div>
            <div class='relations'>
              関連：isEndWith、isStartWith、index
            </div>
            
          </div>
        </div>
        <div>
          <h3>isStartWith</h3>
          <div class="text">
            文字列の先頭が指定の文字列（正規表現文字列）であるか否かを返す

            Boolean ret = isStartWith( String str, String phraze )
            str : 判定対象の文字列を指定します。
            phraze : 先頭の文字列（正規表現文字列）を指定します。
            ret : strの先頭がphrazeであるならばtrue、そうでなければfalseを返します。
            
            例：
            <div class="code">
              $ustr.isStartWith( "abc,def", "abc" );
              > true
            </div>
            <div class='relations'>
              関連：isInclude、isEndWith
            </div>
            
          </div>
        </div>
        <div>
          <h3>isBlank</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、isEmptyの別名です。
            </div>
            
          </div>
        </div>
        <div>
          <h3>lines</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、eachの別名です。
            </div>
            
          </div>
        </div>
        <div>
          <h3>ljust</h3>
          <div class="text">
            文字列を指定文字数内で左寄せします。

            String ret = ljust( String str, Number num, String pad = " " )
            str : 左寄せしたい文字列を指定します。
            num : 左寄せする行の最大文字数を指定します。
            pad : (option) 左寄せの際に埋める文字（デフォルトは空白文字）を指定します。
            ret : 左寄せした文字列を返します。

            例：
            <div class="code">
              $ustr.ljust( "left", 10 );
              > "left      "
              $ustr.ljust( "left", 15, "-*" );
              > "left-*-*-*-*-*-"
            </div>
          </div>
        </div>
        <div>
          <h3>oct</h3>
          <div class="text">
            文字列を8進数とみなし、整数（数値）に変換します。
            文字列の先頭に0oを含むことができます。
            数値に変換できない場合には、0を返します。

            Number ret = oct( String str )
            str : 変換対象の文字列を指定します。
            ret : 変換した数値を返します。
            
            <div class='relations'>
              関連：bin、dec、hex
            </div>

          </div>
        </div>
        <div>
          <h3>padding</h3>
          <div class="text">
            指定の文字列で、指定の文字数を埋めます。

            String ret = padding( String str, Number  num )
            str : 埋める文字を指定します。
            num : 必要な文字数を指定します。
            ret : 指定文字で埋めた結果を返します。

            例：
            <div class="code">
              $ustr.padding( "-", 5 );
              > "-----"
              $ustr.padding( "-*", 5 );
              > "-*-*-"
            </div>
            <div class='relations'>
              本メソッドは、fillの別名です。
            </div>
            <div class='relations'>
              関連：times
            </div>

          </div>
        </div>
        <div>
          <h3>remove</h3>
          <div class="text">
            文字列から指定の文字（正規表現文字列）を削除して返します。

            String ret = remove( String str, String phraze )
            str : 削除元の文字列を指定します。
            phraze : 削除したい文字列（正規表現文字列）を指定します。
            ret : 削除後の文字列を返します。

          </div>
        </div>
        <div>
          <h3>right</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、rjustの別名です。
            </div>
            
          </div>
        </div>
        <div>
          <h3>rjust</h3>
          <div class="text">
            文字列を指定文字数内で右寄せします。

            String ret = rjust( String str, Number num, String pad = " " )
            str : 右寄せしたい文字列を指定します。
            num : 右寄せする行の最大文字数を指定します。
            pad : (option) 右寄せの際に埋める文字（デフォルトは空白文字）を指定します。

            例：
            <div class="code">
              $ustr.rjust( "right", 10 );
              > "     right"
              $ustr.rjust( "right", 15, "-*" );
              > "-*-*-*-*-*right"
            </div>
          </div>
        </div>
        <div>
          <h3>left</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、ljustの別名です。
            </div>
            
          </div>
        </div>
        <div>
          <h3>findWord</h3>
          <div class="text">
            文字列（英文）を単語単位に分割して、配列で返します。

            Array ret = findWord( String str )
            str : 分割対象の文字列を指定します。
            ret : 配列を返します。

            例：
            <div class="code">
              $ustr.findWord( "This is commonFunctions" );
              > [ "This", "is", "common", "Functions" ]
            </div>

            <div class='relations'>
              関連：findEmail、findIp、findPhone、findUrl
            </div>

          </div>
        </div>
        <div>
          <h3>toByteArray</h3>
          <div class="text">
            文字列を1byteごとのバイトコードの配列に変換します。

            Array ret = toByteArray( String str )
            str : バイトコード配列に変換したい文字列を指定します。
            ret : バイトコードの配列を返します。

            <div class='relations'>
              関連：byteSize、eachByte
            </div>

          </div>
        </div>
        <div>
          <h3>byteCodes</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、toByteArrayの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>toF</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、floatの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>toI</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、decの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>toS</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、String.toStringの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>lstrip</h3>
          <div class="text">
            行頭の空白、タブ、改行コードを削除して返します。

            String ret = lstrip( String str )
            str : 削除対象の文字列を指定します。
            ret : 削除後の文字列を返します。

            <div class='relations'>
              関連：rstrip、strip
            </div>

          </div>
        </div>
        <div>
          <h3>rstrip</h3>
          <div class="text">
            行末の空白、タブ、改行コードを削除して返します。

            String ret = rstrip( String str )
            str : 削除対象の文字列を指定します。
            ret : 削除後の文字列を返します。

            <div class='relations'>
              関連：lstrip、strip
            </div>

          </div>
        </div>
        <div>
          <h3>strip</h3>
          <div class="text">
            行末・行頭の空白、タブ、改行コードを削除して返します。

            String ret = strip( String str )
            str : 削除対象の文字列を指定します。
            ret : 削除後の文字列を返します。

            <div class='relations'>
              関連：lstrip、rstrip
            </div>

          </div>
        </div>
        <div>
          <h3>next</h3>
          <div class="text">
            次の文字を生成して返します。
            末尾の文字が半角英字の時、aはb、bはcに更新します。
            数値ならば、0は1、1は2へと更新します。
            zや9などであれば、繰り上げを行います。

            String ret = next( String str )
            str : 次の文字を生成したい対象の文字列を指定します。
            ret : 次の文字を返します。

            例：
            <div class="code">
              $ustr.next( "1" );
              > "2"
              $ustr.next( "2" );
              > "3"
              $ustr.next( "9" );
              > "10"
              $ustr.next( "a" );
              > "b"
              $ustr.next( "ZZ" );
              > "AAA"
            </div>
            <div class='relations'>
              関連：upto
            </div>
            <div class='relations'>
              本メソッドは、succの別名です。
            </div>

          </div>
        </div>        
        <div>
          <h3>succ</h3>
          <div class="text">
            succは、successorの略名。

            <div class='relations'>
              本メソッドは、nextの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>prev</h3>
          <div class="text">
            前の文字を生成して返します。
            末尾の文字が半角英字の時、cはb、bはaに更新します。
            数値ならば、2は1、1は0へと更新します。
            1桁目がa、A、0の時、繰り下げが発生します。
            これ以上繰り下げできない時（上記文字のみの時）、同じ文字を返します。
            
            String ret = prev( String str )
            str : 前の文字を生成したい対象の文字列を指定します。
            ret : 前の文字を返します。

            例：
            <div class="code">
              $ustr.prev( "2" );
              > "1"
              $ustr.next( "1" );
              > "0"
              $ustr.next( "10" );
              > "9"
              $ustr.next( "b" );
              > "a"
              $ustr.next( "AA" );
              > "Z"
            </div>
            <div class='relations'>
              関連：downto、prev、succ、upto
            </div>
            <div class='relations'>
              本メソッドは、anteの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>ante</h3>
          <div class="text">
            anteはantecessorの略
            
            <div class='relations'>
              本メソッドは、prevの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>partition</h3>
          <div class="text">
            文字列中に指定文字（正規表現文字列）を含む場合には、その位置を中心に、
            マッチした文字列の前、マッチした文字列、マッチした文字列の後の３つの文字列に分割し、配列で返します。
            マッチする箇所が無い場合には、文字列の全体、空文字、空文字の３つの文字列を配列で返します。
            マッチする箇所が複数存在する場合には、最初にマッチする位置が中心となります。

            Array ret = partition( String str, String phraze )
            str : 分割対象の文字列を指定します。
            phraze : 分割の中心となる文字列（正規表現文字列）を指定します。
            ret : 分割結果の文字列を配列で返します。

            例：
            <div class="code">
              $ustr.partition( "abcdef", "cd" );
              > [ "ab", "cd", "ef" ]
              $ustr.partition( "abcdef", "[fdc]" );
              > [ "ab", "c", "def" ]
              $ustr.partition( "abcdef", "CD" );
              > [ "abcdef", "", "" ]
            </div>
            <div class='relations'>
              関連：rpartition
            </div>

          </div>
        </div>
        <div>
          <h3>reverse</h3>
          <div class="text">
            指定文字列を逆転して返します。

            String ret = reverse( String str )
            str : 逆転させたい文字列を指定します。
            ret : 逆転させた文字列を返します。

          </div>
        </div>
        <div>
          <h3>rindex</h3>
          <div class="text">
            文字列内に指定の文字列（正規表現文字列）が含まれているとき、最後に見つかった位置を返します。
            文字の位置は、1文字目を0、2文字目を1とし、文字列が含まれていない時にはnullを返します。
            offsetに文字位置を指定した場合には、それ以降の文字列を無視します。
            offsetは文字列の先頭から数えて、1文字目を0、2文字目を1として指定します。
            offsetに3を指定した場合には、4文字目以降を無視して処理します。

            Number ret = index( String str, String phraze, Number offset )
            str : 判定対象の文字列を指定します。
            phraze : 判定対象に含まれる文字列（正規表現文字列）を指定します。
            offset : (option) 検索を開始する文字位置を指定します。
            ret : str内のphrazeを含む位置を返します。
            
            <div class='relations'>
              関連：isInclude、index、lastIndexOf、search
            </div>
            
          </div>
        </div>
        <div>
          <h3>rpartition</h3>
          <div class="text">
            文字列中に指定文字（正規表現文字列）を含む場合には、その位置を中心に、
            マッチした文字列の前、マッチした文字列、マッチした文字列の後の３つの文字列に分割し、配列で返します。
            マッチする箇所が無い場合には、文字列の全体、空文字、空文字の３つの文字列を配列で返します。
            マッチする箇所が複数存在する場合には、最後にマッチする位置が中心となります。

            Array ret = rpartition( String str, String phraze )
            str : 分割対象の文字列を指定します。
            phraze : 分割の中心となる文字列（正規表現文字列）を指定します。
            ret : 分割結果の文字列を配列で返します。
            
            例：
            <div class="code">
              $ustr.rpartition( "abcdef", "cd" );
              > [ "ab", "cd", "ef" ]
              $ustr.rpartition( "abcdef", "[fdc]" );
              > [ "abcde", "f", "" ]
              $ustr.partition( "abcdef", "CD" );
              > [ "", "", "abcdef" ]
            </div>
            <div class='relations'>
              関連：partition
            </div>

          </div>
        </div>
        <div>
          <h3>scan</h3>
          <div class="text">
            文字列中の指定フレーズ（正規表現文字列）にマッチする箇所を、配列で返します。
            マッチする箇所がなければ、空の配列を返します。
            正規表現のパターンの中に()がある場合には、()内にマッチする箇所を、２次元配列にして返します。

            Array ret = scan( String str, String phraze )
            str : マッチ対象の文字列を指定します。
            phraze : マッチさせたい文字列、または正規表現文字列を指定します。
            ret : マッチした文字列を配列で返します。

            例：
            <div class="code">
              $ustr.scan( "hello world!", "o" );
              > [ "o", "o" ]
              $ustr.scan( "hello world!", "([\w]+)" );
              > [ [ "hello" ], [ "world" ] ]
              $ustr.scan( "foo:bar, baz:qux", "([\w]+):([\w]+)" );
              > [ [ "foo", "bar" ], [ "baz", "qux" ] ]
            </div>

          </div>
        </div>
        <div>
          <h3>setByte</h3>
          <div class="text">
            文字列の指定byte目を、任意のバイトコードに置き換えます。
            位置は0オリジンで指定し、1byte目を0。2byte目を1とします。
            マイナス値を指定した場合には、文字列の末尾から数えたbyte数となり、
            -1は末尾のバイトコードを、-2は末尾から2番目のバイトコードとなります。
            範囲外の位置を指定した場合には、文字列の置き換えをせずに、
            元のままの文字列が返します。

            String ret = setByte( String str, Number index, Number code )
            str : 対象の文字列を指定します。
            index : 変更したいbyte単位の位置
            code : 置き換えるバイトコード
            ret : 置換後の文字列を返します

            例：
            <div class="code">
              $ustr.setByte( "hello world", 1, 0x45 );
              > "hEllo world"
              $ustr.setByte( "hello world", -3, 0x52 );
              > "hello woRld"
            </div>
            <div class='relations'>
              関連：byteSize、eachByte、getByte、toByteArray
            </div>

          </div>
        </div>
        <div>
          <h3>squeeze</h3>
          <div class="text">
            文字列中の連続した同一文字を１つの文字にまとめた文字列を返します
            第二引数以降を指定した場合には、一致する条件のみが短縮対象となります。
            条件が複数存在する場合には、第三、第四引数など可変長引数での指定が可能で、これらの条件同士はANDとなります。
            また、一致条件には文字列の他、正規表現を使用することが可能です。

            String ret = squeeze( String str, String condition... )
            str : 対象の文字列を指定します。
            condition : (option) 一致条件を指定します。
            ret : 変換後の文字列を返します。

            例：
            <div class="code">
              $ustr.squeeze( "hello  world" );
              > "helo world"
              $ustr.squeeze( "おおおかえちぜん" );
              > "おかえちぜん"
              $ustr.squeeze( "aaa   bbbc", /[a-z]/ );
              > "a   bc"
              $ustr.squeeze( "aaa   bbbc", /[a-z]/, "b" );
              > "aaa   bc"
            </div>

          </div>
        </div>
        <div>
          <h3>sum</h3>
          <div class="text">
            文字列を元に、整数のチェックサム値を返します。
            チェックサム値は、文字列の各byteを整数として合計し、下位ビットを取り出します。
            特に指定が無い場合には、下位16bitを取得します。

            Number ret = sum( String str, Number bits )
            str : 対象の文字列を指定します。
            bits : (option) 取得したい下位ビット数を指定します。デフォルトは16です。
            ret : チェックサム値を返します。

          </div>
        </div>
        <div>
          <h3>swapcase</h3>
          <div class="text">
            文字列中の英字を、大文字を小文字に、小文字を大文字に変換して返します。

            String ret = swapcase( String str )
            str : 対象の文字列を指定します。
            ret : 変換後の文字列を返します。

            例：
            <div class="code">
              $ustr.swapcase( "Hello World!" );
              > "hWLLO wORLD!"
            </div>

          </div>
        </div>
        <div>
          <h3>upto</h3>
          <div class="text">
            開始文字列が、終了文字列になるまで「次の文字列」を繰り返し生成し、引数に指定の関数を実行します。
            また、生成した「次の文字列」は、配列で戻り値として返します。
            「次の文字列」がどの様に生成されるかは、 <span class="relations">next、succ</span> を参照してください。
            開始文字列から「次の文字列」を繰り返し生成する延長線上に終了文字列が無い場合には、生成される文字列は開始文字列のみとなります。
            ただし、65535件を超えて「次の文字列」は生成されません。

            Array ret = upto( String org, String dest, Function block )
            org : 開始文字列を指定します。
            dest : 終了文字列を指定します。
            ret : 生成した文字列を配列で返します。

            例：
            <div class="code">
              $ustr.upto( "a", "d" );
              > [ "a", "b", "c", "d" ]

              $ustr.upto( "a9x", "b0b", function( str ){ console.log(str) } );
              > "a9x"
              > "a9y"
              > "a9z"
              > "b0a"
              > "b0b"
              > [ "a9x", "a9y", "a9z", "b0a", "b0b" ]
            </div>
            <div class='relations'>
              関連：downto、next、succ
            </div>

          </div>
        </div>
        <div>
          <h3>downto</h3>
          <div class="text">
            開始文字列が、終了文字列になるまで「前の文字列」を繰り返し生成し、引数に指定の関数を実行します。
            また、生成した「前の文字列」は、配列で戻り値として返します。
            「前の文字列」がどの様に生成されるかは、 <span class="relations">ante、prev</span> を参照してください。
            開始文字列から「前の文字列」を繰り返し生成する延長線上に終了文字列が無い場合には、生成される文字列は開始文字列のみとなります。
            ただし、65535件を超えるて「前の文字列」は生成されません。

            Array ret = downto( String org, String dest, Function block )
            org : 開始文字列を指定します。
            dest : 終了文字列を指定します。
            ret : 生成した文字列を配列で返します。

            例：
            <div class="code">
              $ustr.downto( "d", "a" );
              > [ "d", "c", "b", "a" ]

              $ustr.upto( "b0b", "a9x", function( str ){ console.log(str) } );
              > "b0b"
              > "b0a"
              > "a9z"
              > "a9y"
              > "a9x"
              > [ "b0b", "b0a", "a9z", "a9y", "a9x" ]
            </div>
            <div class='relations'>
              関連：ante、prev、upto
            </div>

          </div>
        </div>
        <div>
          <h3>times</h3>
          <div class="text">
            指定文字列を指定回数だけ繰り返した文字列を返します。
            繰り返し回数に0を指定した場合には、空文字を返します。
            繰り返し回数に負の数を指定した場合には、逆転した文字列を、繰り返し回数だけ生成します。

            Array ret = times( String str, Number num )
            str : 繰り返したい文字列を指定します。
            num : 繰り返し回数を指定します。
            ret : 生成した文字列を配列で返します。

            例：
            <div class="code">
              $ustr.times( "abc", 3 );
              > "abcabcabc"

              $ustr.times( "abc", -2 );
              > "cbacba"
            </div>
            <div class='relations'>
              関連：padding
            </div>
            <div class='relations'>
              本メソッドは、repeatの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>repeat</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、timesの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>toString</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.toStringと同一です。

            String ret = toString( String str )
            str : 文字列を指定します
            ret : 文字列オブジェクトを返します。
            
            <div class='relations'>
              本メソッドは、toSの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>charAt</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.charAtと同一です。
            指定文字中の、指定位置の文字を返します。
            文字の位置は、1文字目を0として指定します。

            String ret = charAt( String str, Number num )
            str : 文字列を指定します
            num : 取得したい文字位置を指定します。
            ret : 指定位置の文字を返します。

            <div class='relations'>
              関連：eachChar
            </div>

          </div>
        </div>
        <div>
          <h3>charCodeAt</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.charAtと同一です。
            指定文字数の指定位置の文字コード（バイトコード）を返します。
            文字の位置は、1文字目を0として指定します。
            文字の位置は、byte数ではなく、文字数であるため、マルチバイト文字も1文字として扱います。

            String ret = charCodeAt( String str, Number num )
            str : 文字列を指定します
            num : 取得したい文字位置を指定します。
            ret : 指定位置の文字コードを返します。

            <div class='relations'>
              関連：getByte、eachByte
            </div>

          </div>
        </div>
        <div>
          <h3>concat</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.concatと同一です。
            ２つの文字列を連結して、１つの文字列にして返します。

            String ret = concat( String org, String dest )
            org : 連結したい元の文字列を指定します。
            dest : 連結したい先の文字列を指定します。
            ret : 連結した文字列を返します。

          </div>
        </div>
        <div>
          <h3>lastIndexOf</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.lastIndexOfと同一です。
            指定文字列の後方から、最初に見つかった指定のフレーズと一致する文字位置を検索し、返します。
            文字位置は1文字目を0とし、一致するフレーズが無い場合には-1を返します。
            また、検索開始位置を指定した場合には、その文字位置よりも前方を検索します。

            String ret = lastIndexOf( String str, String phraze, Number from )
            str : 検索したい文字列を指定します。
            phraze : 検索したいフレーズ文字列を指定します。
            from : (option) 検索開始位置を指定します。
            ret : 最初に一致した位置を返します。

            <div class='relations'>
              関連：rindex、isInclude、index、search
            </div>

          </div>
        </div>
        <div>
          <h3>match</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.matchと同一です。
            指定文字列中の、指定フレーズ（または正規表現オブジェクト）と一致する時、一致した部分の文字列を配列で返します。
            一致しなかった場合には、nullを返します。

            Array ret = match( String str, String phraze )
            str : 検索したい文字列を指定します。
            phraze : 検索したいフレーズ文字列（または正規表現オブジェクト）を指定します。
            ret : 一致した文字列を配列で返します。

          </div>
        </div>
        <div>
          <h3>replace</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.replaceと同一です。
            指定文字列中の、指定フレーズ（または正規表現オブジェクト）と一致する時、一致した部分の文字列を指定文字列で置換し、
            置換後の文字列を返します。

            String ret = replace( String str, String phraze, String rep )
            str : 置換元の文字列を指定します。
            phraze : 置換したいフレーズ文字列（または正規表現オブジェクト）を指定します。
            rep : 置換する文字列を指定します。
            ret : 置換後の文字列を返します。

          </div>
        </div>
        <div>
          <h3>search</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.searchと同一です。
            指定文字の前方から、指定フレーズ（または正規表現オブジェクト）と一致する文字位置を検索し、返します。
            一致しなかった場合には、-1を返します。

            Number ret = search( String str, String phraze )
            str : 検索したい文字列を指定します。
            phraze : 検索したいフレーズ文字列（または正規表現オブジェクト）を指定します。
            ret : 一致した文字の位置を返します。

            <div class='relations'>
              関連：rindex、isInclude、index、lastIndexOf
            </div>

          </div>
        </div>
        <div>
          <h3>slice</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.sliceと同一です。
            指定文字の開始文字位置から後の文字列を取り出して返します。
            開始文字位置は、1文字目を0として指定します。
            負の数を指定した場合には、指定文字の後方から数えた位置から開始します。
            この時、-1は最後の文字位置を示します。
            文字を取り出す終了位置を指定しない場合には、開始位置以降の全ての文字列を取得します。
            終了位置を指定した場合には、開始位置から終了位置の直前まで（つまり、終了位置の-1文字目まで）の文字列を取得します。

            String ret = slice( String str, Number start, Number end )
            str : 元の文字列を指定します。
            start : 文字を取り出す開始位置を指定します。
            end : (option) 文字を取り出す終了位置を指定します。
            ret : 取り出した文字列を返します。

            <div class='relations'>
              関連：substr、substring
            </div>

          </div>
        </div>
        <div>
          <h3>substr</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.substrと同一です。
            指定文字の開始文字位置から後の文字列を取り出して返します。
            開始文字位置は、1文字目を0として指定します。
            負の数を指定した場合には、指定文字の後方から数えた位置から開始します。
            この時、-1は最後の文字位置を示します。
            文字数を指定しない場合には、開始位置以降の全ての文字列を取得します。
            文字数を指定した場合には、開始位置から文字数分だけを取り出します。

            String ret = substr( String str, Number index, Number len )
            str : 元の文字列を指定します。
            index : 文字を取り出す開始位置を指定します。
            len : (option) 取り出す文字数を指定します。
            ret : 取り出した文字列を返します。

            <div class='relations'>
              関連：slice、substring
            </div>

          </div>
        </div>
        <div>
          <h3>substring</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.substringと同一です。
            指定文字の開始文字位置から後の文字列を取り出して返します。
            開始文字位置は、1文字目を0として指定します。
            負の数を指定した場合には、最初の文字位置が指定されたものとみなします。
            この時、-1は最後の文字位置を示します。
            文字を取り出す終了位置を指定しない場合には、開始位置以降の全ての文字列を取得します。
            終了位置を指定した場合には、開始位置から終了位置の直前まで（つまり、終了位置の-1文字目まで）の文字列を取得します。

            String ret = substring( String str, Number start, Number end )
            str : 元の文字列を指定します。
            start : 文字を取り出す開始位置を指定します。
            end : (option) 文字を取り出す終了位置を指定します。
            ret : 取り出した文字列を返します。

            <div class='relations'>
              関連：substr、slice
            </div>

          </div>
        </div>
        <div>
          <h3>split</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.splitと同一です。
            指定文字を指定のフレーズ文字列と一致する箇所で分割し、分割後の文字列を配列で返します。
            空文字を分割するフレーズ文字列として指定すると、全ての文字を1文字ごとに分割します。
            フレーズ文字列を指定して分割した場合には、分割後の文字列に、フレーズ文字列は含まれません。
            また、分割の最大数を指定した場合には、分割処理を全て行った後に、最大数分の配列だけを返します。
            つまり、分割後の文字列が本来は3つなる場合に、最大数を2とした場合には、最初の2つの分割された文字列だけが帰ります。
            この時、3つ目の分割後の文字列は取得されません。

            Array ret = split( String str, String phraze, Number limit )
            str : 分割元の文字列を指定します。
            pharze : 分割したいフレーズを指定します。
            limit : (option) 分割する最大数を指定します。
            ret : 分割した文字列の配列を返します。

          </div>
        </div>
        <div>
          <h3>toLowerCase</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.toLowerCaseと同一です。
            指定文字列中の半角英字の大文字を、全て小文字に変換して返します。
            他の文字については、何も変換せずに、そのまま返します。

            String ret = toLowerCase( String str )
            str : 対象の文字列を指定します。
            ret : 変換後の文字列を返します。

            <div class='relations'>
              関連：capitalize、casecmp、toUpperCase
            </div>

          </div>
        </div>
        <div>
          <h3>toUpperCase</h3>
          <div class="text">
            JavaScriptのStringオブジェクトのメソッド、String.toUpperCaseと同一です。
            指定文字列中の半角英字の小文字を、全て大文字に変換して返します。
            他の文字については、何も変換せずに、そのまま返します。

            String ret = toUpperCase( String str )
            str : 対象の文字列を指定します。
            ret : 変換後の文字列を返します。

            <div class='relations'>
              関連：capitalize、casecmp、toLowerCase
            </div>

          </div>
        </div>
        <div>
          <h3>findPhone</h3>
          <div class="text">
            指定文字列中から電話番号のフォーマットと一致する文字列を抽出して、配列で返します。
            電話番号のフォーマットは、日本の電話番号（携帯電話を含む）を対象とし、国際電話番号を含むことができます。
            短縮ダイヤルなどの#（スクエア）や*（スター）には対応していません。
            strictフラグを指定した場合には、マッチさせる電話番号のフォーマットが厳格になります。
            具体的には、市外局番の無いものは電話番号とはみなしません。
            また、先頭は国際電話番号で日本を表す「81」か国内電話番号を表す「0」に始まり、
            固定電話では、市外局番と市内局番の合計が5桁、加入者番号が4桁である必要があります。
            携帯電話・PHSでは、090または070の後に、４桁+4桁の計8桁の加入者番号が続く必要があります。
            市外局番、市内局番、加入者番号間の、"-"や"(",")"は電話番号に含むことができます。
            strictフラグのデフォルトはtrueです。

            Array ret = findPhone( String str, Boolean strict )
            str : 対象の文字列を指定します。
            strict : (option) できるだけ厳密に電話番号にマッチさせるか否かを指定します。
            ret : 抽出した電話番号文字列を配列で返します。

            <div class='relations'>
              関連：findEmail、findWord、findUrl
            </div>

          </div>
        </div>
        <div>
          <h3>findTel</h3>
          <div class="text">
            <div class='relations'>
              本メソッドは、findPhoneの別名です。
            </div>

          </div>
        </div>
        <div>
          <h3>findEmail</h3>
          <div class="text">
            指定文字列中からメールアドレスのフォーマットと一致する文字列を抽出して、配列で返します。
            strictフラグを指定した場合には、マッチさせるメールアドレスのフォーマットが厳格になります。
            具体的には、HTMLのINPUT要素のTYPE=EMAILとした時に入力が許容されるフォーマットと一致します。
            このフォーマット（strict時）は、RFC5322をベースとしていますが、過去に携帯電話向けのアドレス等で
            規約に合致しないものが現在でも使用されている経緯があり、厳密にはRFC5322には準拠していません。
            strictフラグのデフォルトはtrueです。

            Array ret = findEmail( String str, Boolean strict )
            str : 対象の文字列を指定します。
            strict : (option) できるだけ厳密にメールアドレスにマッチさせるか否かを指定します。
            ret : 抽出したメールアドレス文字列を配列で返します。

            <div class='relations'>
              関連：findPhone、findIp、findWord、findUrl
            </div>

          </div>
        </div>
        <div>
          <h3>findUrl</h3>
          <div class="text">
            指定文字列中からURLのフォーマットと一致する文字列を抽出して、配列で返します。
            strictフラグを指定した場合には、マッチさせるURLのフォーマットが厳格になります。
            具体的には、RFC2396/3986に準拠した、スキーマを含んだ絶対パスのURLとマッチします。
            strictフラグのデフォルトはtrueです。
            strictフラグがfalseの場合には、相対パスともマッチします。

            Array ret = findUrl( String str, Boolean strict )
            str : 対象の文字列を指定します。
            strict : (option) できるだけ厳密にURLにマッチさせるか否かを指定します。
            ret : 抽出したURL文字列を配列で返します。

            <div class='relations'>
              関連：findEmail、findIp、findPhone、findWord、parseUrl
            </div>

          </div>
        </div>
        <div>
          <h3>findIp</h3>
          <div class="text">
            指定文字列中からIPアドレスのフォーマットと一致する文字列を抽出して、配列で返します。
            本メソッドでは、IPv4及びIPv6両方のアドレスに対応し、CIDR表記にもマッチします。

            Array ret = findIp( String str )
            str : 対象の文字列を指定します。
            ret : 抽出したURL文字列を配列で返します。

            <div class='relations'>
              関連：findEmail、findIp4、findIp6、findPhone、findUrl、findWord
            </div>

          </div>
        </div>
        <div>
          <h3>findIp4</h3>
          <div class="text">
            指定文字列中からIPv4のフォーマットと一致する文字列を抽出して、配列で返します。
            本メソッドでは、IPv4のアドレスに対応し、CIDR表記にもマッチします。

            Array ret = findIp4( String str )
            str : 対象の文字列を指定します。
            ret : 抽出したURL文字列を配列で返します。

            <div class='relations'>
              関連：findEmail、findIp、findIp6、findPhone、findUrl、findWord
            </div>

          </div>
        </div>
        <div>
          <h3>findIp6</h3>
          <div class="text">
            指定文字列中からIPv6のフォーマットと一致する文字列を抽出して、配列で返します。
            本メソッドでは、IPv6のアドレスに対応し、CIDR表記にもマッチします。

            Array ret = findIp6( String str )
            str : 対象の文字列を指定します。
            ret : 抽出したURL文字列を配列で返します。

            <div class='relations'>
              関連：findEmail、findIp、findIp4、findPhone、findUrl、findWord
            </div>

          </div>
        </div>
        <div>
          <h3>parseUrl</h3>
          <div class="text">
            指定の文字列をURLとして解析し、スキーマ、ドメイン、パス、フラグメント、クエリーなどの各部ごとに分解した連想配列を返します。
            取得される連想配列のキー名が、URLを分解した際の部位名となり、以下のキー名で取得されます。
            <div class="code">
              url : 解析しようとした元のurl全体
              schema : スキーマの文字列（末尾の:は含まない）
              user : ユーザIDの文字列
              password : パスワードの文字列
              fqdn : ホスト＋ドメイン名、またはIPv4、IPv6の文字列
              host : ホスト名の文字列
              domain : ドメイン名の文字列
              ip4 : IPv4形式だった場合の該当部の文字列
              ip6 : IPv6形式だった場合の該当部の文字列
              port : ポート番号の文字列
              path : パスの文字列
              query : クエリの文字列
              queries : クエリの文字列をkey=value形式にした、連想配列
              fragment : フラグメントの文字列
            </div>
            連想配列の各部位の値は、URLから取得できなかった場合にはnullが設定されます。
            また、指定の文字列をURLとして解析できなかった場合には、本メソッドはnullを返します。

            Object ret = parseUrl( String url )
            url : 解析対象のURL文字列を指定します。
            ret : 解析結果を連想配列で返します。

            <div class='relations'>
              関連：findUrl、parsePath、mergeUrl
            </div>

          </div>
        </div>
        <div>
          <h3>mergeUrl</h3>
          <div class="text">
            ２つのURL文字列を合成して、１つの絶対パスのURLを生成します。
            合成元になる絶対パスのURLと、相対パスによる組み合わせで指定されることを想定しています。
            ２つとも絶対パスのURLを指定した場合には合成をせず、２つ目のURLが優先されます。
            ２つとも相対パスであった場合には、１つ目のURL上のパスをカレントと見なして、合成します。
            URLのパス部の最後が"/"ではない場合。例えば、"http://exsample.com/foo/bar"の時。
            "bar"はファイルとみなされ、"/foo/"がカレントのパスとして扱われます。
            "bar"をディレクトリとして扱いたい場合には、"bar/"の様に、最後に"/"を付ける必要があります。
            合成元のURL（両方または片方）が、URLとして認識できなかった場合には、nullを返します。

            String ret = mergeUrl( String url1, String url2 )
            url1 : 合成元のURL（１つ目）文字列を指定します。
            url2 : 合成元のURL（２つ目）文字列を指定します。
            ret : 合成結果のURLを返します。

            <div class='relations'>
              関連：findUrl、parseUrl、mergePath
            </div>

          </div>
        </div>
        <div>
          <h3>parsePath</h3>
          <div class="text">
            指定の文字列をパス（path。コンピュータ内の特定資源の場所を示すもの。ディレクトリ名とその階層、ファイル名などで構成）として解析し、
            ルート（ディレクトリ）、ディレクトリ、ファイル、デリミタなどの各部ごとに分解した連想配列を返します。
            取得される連想配列のキー名が、パスを分解した際の部位名となり、以下のキー名で取得されます。
            <div class="code">
              path : 解析しようとした元のpath全体
              root : ルート階層。windowsの場合は"c:¥"（"c:"が取得される）、linux系では"/root/"（"root"が取得される）など
              directory : ディレクトリ部の文字列。
              directories : ディレクトリ部を1階層ごとに分割し、配列化したもの
              file : ファイル名の文字列（拡張子を含む）
              extension : 拡張子
              delimiter : ディレクトリ階層を区切る文字。"/"または"¥"
            </div>
            連想配列の各部位の値は、パスから取得できなかった場合にはnullが設定されます。
            また、指定の文字列をパスとして解析できなかった場合には、本メソッドはnullを返します。

            Object ret = parsePath( String path )
            path : 解析対象のパス文字列を指定します。
            ret : 解析結果を連想配列で返します。

            <div class='relations'>
              関連：findUrl、parseUrl、mergePath
            </div>

          </div>
        </div>
        <div>
          <h3>mergePath</h3>
          <div class="text">
            ２つのパス文字列を合成して、１つの絶対パスのURLを生成します。
            合成元になる絶対パスと、相対パスによる組み合わせで指定されることを想定しています。
            ２つとも絶対パスを指定した場合には合成をせず、２つ目のパスが優先されます。
            ２つとも相対パスであった場合には、１つ目のパスをカレントと見なして、合成します。
            パスの最後が"/"ではない場合。例えば、"/foo/bar/baz"の時。
            "baz"はファイルとみなされ、"/foo/bar/"がディレクトリとして扱われます。
            "baz"をディレクトリとして扱いたい場合には、"baz/"の様に、最後に"/"を付ける必要があります。
            合成元のパス（両方または片方）が、パスとして認識できなかった場合には、nullを返します。

            String ret = mergePath( String path1, String path2 )
            path1 : 合成元のパス（１つ目）文字列を指定します。
            path2 : 合成元のパス（２つ目）文字列を指定します。
            ret : 合成結果のパスを返します。

            <div class='relations'>
              関連：findUrl、parsePath、mergeUrl
            </div>

          </div>
        </div>        
        <div>
          <h3>diff</h3>
          <div class="text">
            指定した2つの文字列を比較し、同一部、追加部、削除部を出力します。
            例えば、"apple"と"approach"を比較した場合に、
            "apple"という文字列を編集して、"approach"という文字列にするために必要な、
            編集内容が比較結果として出力されます。
            具体的には、"app"は同一、"le"は削除。"roach"を追加、です。

            比較結果は、以下の様なオブジェクトによる配列で返します。
            配列に格納される順序は、比較元文字列を編集する順序と一致します。
            <div class="code">
              return_value = [
                {
                  value: "app",
                  type: "="
                },
                {
                  value: "le",
                  type: "-"
                },
                {
                  value: "roach",
                  type: "+"
                },
              ]
            </div>
            "value"のキー名には、編集内容の文字列が格納されます。
            "type"のキー名には、編集方法が格納されます。
            編集方法は、以下の3種類です。
            = : 編集なし。比較元と比較先で同一の文字列であることを示す。
            - : 比較元から削除される文字列
            + : 比較先から追加された文字列
            
            Array ret = diff( String org, String dest )
            org : 比較元の文字列を指定します。
            dest : 比較先の文字列を指定します。
            ret : 比較結果のオブジェクトによる配列を返します。

            <div class='relations'>
                関連：diffLine
            </div>

          </div>
        </div>
        <div>
            <h3>diffLine</h3>
            <div class="text">
              指定した2つの文字列を比較し、行単位で同一部、追加部、削除部を出力します。
              使用方法や戻り値の形式は、 <span class="relations">diff</span> と同様です。
              本メソッドが異なる点は、行単位で差分を算出することであり、行内の文字の部分的な差位は出力しません。
  
              比較結果は、以下の様なオブジェクトによる配列で返します。
              配列に格納される順序は、比較元の行の順序と同一です。
              <div class="code">
                return_value = [
                  {
                    value: [ "1st line", "2nd line" ],
                    type: "="
                  },
                  {
                    value: [ "3rd line" ],
                    type: "-"
                  },
                  {
                    value: [ "4th line" ],
                    type: "+"
                  },
                ]
              </div>
              "value"のキー名には、行単位の文字列が配列で格納されます。
              "type"のキー名には、編集方法が格納されます。
              編集方法は、以下の3種類です。
              = : 編集なし。比較元と比較先で同一の行であることを示す。
              - : 比較元から削除される行
              + : 比較先から追加された行
              
              Array ret = diffLine( String org, String dest )
              org : 比較元の文字列を指定します。
              dest : 比較先の文字列を指定します。
              ret : 比較結果のオブジェクトによる配列を返します。
  
              <div class='relations'>
                  関連：diff
              </div>

            </div>
          </div>
          <!--
          getBlock : 指定の囲み文字内を取得する（エスケープを考慮）
          parseCvs
          formats
          escapeHtml : サニタイジングします
          unescapeHtml
          plural
          singular
          safeString : nullなどは空文字として返す
          encodeCaesarCipher / decodeCaesarCipher : シーザー暗号。アルファベットの文字コードを任意の数だけずらす
          encodeLeet / decodeLeet : https://ja.wikipedia.org/wiki/Leet
          similarity : ２つの文字の類似度を算出（レーベンシュタイン距離？）
         -->
      </div>
    </div>
    <div class="page" id="grape-utility-number">
      <h2>数値</h2>
      <a name="grape-utility-number"></a>
      <div class='text'>
        ファイル : grape-utility-number.js
        オブジェクト型 : $UNum
        インスタンス : $unum
        
      </div>
      <div class="section">
        <div class="text">
        </div>
      </div>
    </div>
    <div class="page" id="grape-utility-array">
      <h2>配列</h2>
      <a name="grape-utility-array"></a>
      <div class='text'>
        ファイル : grape-utility-array.js
        オブジェクト型 : $UAry
        インスタンス : $uary
        
      </div>
      <div class="section">
        <div class="text">
        </div>
      </div>
    </div>
    <div class="page" id="grape-utility-datetime">
      <h2>日付</h2>
      <a name="grape-utility-datetime"></a>
      <div class='text'>
        ファイル : grape-utility-datetime.js
        オブジェクト型 : $UDate
        インスタンス : $udate
        
      </div>
      <div class="section">
        <div class="text">
        </div>
      </div>
    </div>
    <div class="page" id="grape-libraries-algorithm">
      <h2>汎用アルゴリズム</h2>
      <a name="grape-libraries-algorithm"></a>
      <div class='text'>
        ファイル : grape-library-algorithm.js
        オブジェクト型 : $LAlg
        インスタンス : $lalg
        
      </div>
      <div class="section">
        <div>
          <h3>getRouteByDijkstra</h3>
          <div class="text">
            X軸とY軸によって構成される2次元空間上の、最短ルートをダイクストラ法によって取得します。
            2次元空間は、数値による2次元配列によって表現するものとし、空間を以下の様な表にみたてて計算をします。

            <table>
              <tr><th>Y/X</th><th>0</th><th>1</th><th>2</th><th>3</th></tr>
              <tr><th>0</th><td>0</td><td>-1</td><td>0</td><td>0</td></tr>
              <tr><th>1</th><td>0</td><td>-1</td><td>2</td><td>1</td></tr>
              <tr><th>2</th><td>0</td><td>0</td><td>0</td><td>0</td></tr>
            </table>
            上記は、X方向に4（0〜3）、Y方向に3（0〜2）の大きさの座標空間を表現しています。
            数値の意味は、
            -1 : 移動できない。（このマスを通過できない）
            0以上 : そのマスを通過するのに必要なコスト（大きいほどコストが高く、通過しづらいことを意味する）

            開始地点を左上(X:0,Y:0)、終了地点を右上(X:3,y:0)とした場合に、
            本メソッドはコストを考慮した上での最短ルートを、以下の様に返します。
            (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (3,1) - >(3,0)

            具体的には、2次元空間として以下の様な2次元配列を本メソッドに指定します。
            この時、2次元配列の添え字が、XY座標と対応し、1次元目をY座標、2次元目がX座標となります。
            <div class="code">
              var map = [
                [  0, -1,  0,  0 ],
                [  0, -1,  2,  1 ],
                [  0,  0,  0,  0 ]
              ];
            </div>
            戻り値は、最短ルートを表現した、以下の様な2次元配列で取得されます。
            <div class="code">
              [
                [ 0, 0 ],  // 開始地点のX,Y座標
                [ 0, 1 ],
                [ 0, 2 ],
                [ 1, 2 ],
                [ 2, 2 ],
                [ 3, 2 ],
                [ 3, 1 ],
                [ 3, 0 ]   // 終了地点のX,Y座標
              ]
            </div>
            開始地点から終了地点に到達できない場合は、nullが返されます。
            本メソッドは移動コストの設定が複雑な場合に、2次元座標空間の大きさに応じて、処理コストが大きくなります。
            100x100程度のサイズとなると、100ミリ秒以上の処理コストがかかる可能性があります。
            （移動コストの設定状況や、実行環境のCPU性能等の影響を受けて処理コストは変化します）
            移動コストの計算が不要な場合には、より高速に動作する <span class="relations">getRouteFastByDijkstra</span> を使用してください。

            Array ret = getRouteByDijkstra( Array map, Number start_x, Number start_y, Number goal_x, Number goal_y )
            map : 座標空間を2次元配列で指定します。
            start_x : 開始X座標を指定します。この場合のX座標とは1つ目の引数の2次元配列の2次元目の添え字（配列のインデックス番号）に相当します。
            start_y : 開始Y座標を指定します。この場合のy座標とは1つ目の引数の2次元配列の1次元目の添え字（配列のインデックス番号）に相当します。
            goal_x : 終了X座標を指定します。座標の意味は開始X座標と同様。
            goal_y : 終了Y座標を指定します。座標の意味は開始Y座標と同様。
            ret : 最短経路を2次元配列で返します。

            <div class='relations'>
              関連：getRouteFastByDijkstra、getRouteNodeByDijkstra
            </div>

          </div>
        </div>
        <div>
          <h3>getRouteFastByDijkstra</h3>
          <div class="text">
            X軸とY軸によって構成される2次元空間上の、最短ルートをダイクストラ法によって取得します。
            本メソッドは、 <span class="relations">getRouteByDijkstra</span> と同じ使用方法となりますます。
            <span class="relations">getRouteByDijkstra</span> と異なる点は、移動コストを考慮せずに最短ルートを算出する点です。
            そのため、より高速に処理することが可能です。

            Array ret = getRouteFirstByDijkstra( Array map, Number start_x, Number start_y, Number goal_x, Number goal_y )
            map : 座標空間を2次元配列で指定します。
            start_x : 開始X座標を指定します。この場合のX座標とは1つ目の引数の2次元配列の2次元目の添え字に相当します。
            start_y : 開始Y座標を指定します。この場合のy座標とは1つ目の引数の2次元配列の1次元目の添え字に相当します。
            goal_x : 終了X座標を指定します。座標の意味は開始X座標と同様。
            goal_y : 終了Y座標を指定します。座標の意味は開始Y座標と同様。
            ret : 最短経路を2次元配列で返します。

            <div class='relations'>
              関連：getRouteByDijkstra
            </div>

          </div>
        </div>
        <div>
          <h3>getRouteNodeByDijkstra</h3>
          <div class="text">
            1対多のコネクションを持つノード間で、最短ルートをダイクストラ法によって取得します。
            本メソッドは、 <span class="relations">getRouteByDijkstra</span> によるルート探索を、2次元配列ではなくノードによって行うものです。
            ノードとコネクションは、以下に詳細を示す通り、JavaScriptのObject型（連想配列）である必要があります。
            ただし、以下に示す以外のキー値等を保持することは制限しない。
            また、Object型として（連想配列として）アクセス可能でさえあれば、prototype継承した別の型であっても良い。
            <div class="code">
              // ノード型
              node = {
                id : 0,           // Number または String型。このノードのID
                connections: []   // このノードから接続している、別ノードを格納するノード接続型オブジェクトによる配列
              };
              // ノード接続型
              node_connection = {
                cost : 0,         // Number型。0以上の数値による移動コスト値
                node : Object     // ノード型オブジェクト。接続先のノード
              };
            </div>
            ノードの接続は、循環構造になっていても良い。
            ノードの接続から、ゴールにたどり着けない場合にはnullを返す。

            Array ret = getRouteNodeByDijkstra( Object start_node, Number(or String) goal_id )
            start_node : 開始位置のノードオブジェクトを指定します。
            goal_id : ゴール位置のノードのIDを指定します。
            ret : 最短経路をノードIDによる配列で返します。

            <div class='relations'>
              関連：getRouteByDijkstra
            </div>

          </div>
        </div>
        <!--
          getFillMapByScanLine : 塗りつぶし（スキャンラインアルゴリズム）http://wais.jp/high-speed-region-fill-method/
          eachLineByScanLine
          getLineMap : 始点〜終点を結ぶ線分を描画したい場合に、描画すべきピクセル位置をマッピングする。http://fussy.web.fc2.com/algo/
          eachPointLine
        -->
      </div>
    </div>
    <div class="page">
      <h2>テスト</h2>
      <div class="section">
        <div class="text">
          <a href="./unitTest.html" target="_blank">テストの実行</a><br/>
        </div>
      </div>
    </div>
  </div>
</body>
</html>

